package com.epam.timekeeper.dao.impl;

import com.epam.timekeeper.dao.CategoryDAO;
import com.epam.timekeeper.dao.MySQLConnector;
import com.epam.timekeeper.dao.SQL;
import com.epam.timekeeper.entity.Category;
import com.epam.timekeeper.exception.AlreadyExistsException;
import com.epam.timekeeper.exception.DBException;

import java.sql.*;
import java.util.*;

public class CategoryDAOImpl extends UtilDAO implements CategoryDAO {

    @Override
    public void create(Category entity) {
        Connection connection = null;
        PreparedStatement statement = null;
        int i = 0;
        int categoryId = 0;
        int langId = 0;
        try {
            connection = MySQLConnector.getConnection();
            connection.setAutoCommit(false);
            connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
            statement = connection.prepareStatement(SQL.Category.CREATE_CATEGORY_ID,
                    Statement.RETURN_GENERATED_KEYS);
            statement.execute();
            try (ResultSet keySet = statement.getGeneratedKeys()) {
                if (keySet.next()) {
                    categoryId = keySet.getInt(++i);
                }
            } catch (SQLException e) {
                e.printStackTrace();
                throw e;
            }
            if (categoryId == 0) {
                throw new SQLException("returned autogenerated key equals 0", "45000");
            }
            for (Map.Entry<String, String> entry :
                    entity.getLangName().entrySet()) {
                i = 0;
                statement = connection.prepareStatement(SQL.Category.GET_LANG_ID);
                statement.setString(++i, entry.getKey());
                statement.execute();
                try (ResultSet resultSet = statement.getResultSet()) {
                    if (resultSet.next()) {
                        i = 0;
                        langId = resultSet.getInt(++i);
                    }
                } catch (SQLException e) {
                    e.printStackTrace();
                    throw e;
                }
                if (langId == 0) {
                    throw new SQLException("could not find langId for lang=" + entry.getKey(), "45000");
                }
                i = 0;
                statement = connection.prepareStatement(SQL.Category.CREATE);
                statement.setInt(++i, categoryId);
                statement.setInt(++i, langId);
                statement.setString(++i, entry.getValue());
                statement.execute();
            }
            connection.commit();
        } catch (SQLException e) {
            rollbackTransaction(connection);
            e.printStackTrace();
            if (e.getSQLState().equals("23000")) {
                throw new AlreadyExistsException(e.getMessage());
            } else {
                throw new DBException("State: " + e.getSQLState() + " Message: " + e.getMessage());
            }
        } finally {
            close(statement);
            close(connection);
        }
    }

    @Override
    public List<Category> readAll() {
        Connection connection = null;
        PreparedStatement statement = null;
        Set<String> langSet;
        List<Category> categoryList = new ArrayList<>();
        int i;
        try {
            connection = MySQLConnector.getConnection();
            langSet = getAllLangNames(connection);
            if (langSet == null) {
                throw new SQLException("error occurred while trying to read all lang", "45000");
            }
            statement = connection.prepareStatement(SQL.Category.READ_ALL_CATEGORIES);
            statement.execute();
            try (ResultSet categoryRS = statement.getResultSet()) {
                while (categoryRS.next()) {
                    i = 0;
                    Category entity = new Category();
                    entity.setId(categoryRS.getInt(++i));
                    entity.setStatus(Category.Status.valueOf(categoryRS.getString(++i)));
                    categoryList.add(entity);
                }
            } catch (SQLException e) {
                e.printStackTrace();
                throw e;
            }
            for (Category c :
                    categoryList) {
                c.setLangName(getLangNameMap(connection, langSet, c.getId()));
            }
            return categoryList;
        } catch (SQLException e) {
            e.printStackTrace();
            throw new DBException("State: " + e.getSQLState() + " Message: " + e.getMessage());
        } finally {
            close(statement);
            close(connection);
        }
    }

    @Override
    public Category readById(int id) {
        Connection connection = null;
        PreparedStatement statement = null;
        Set<String> langSet;
        Category category = new Category();
        int i = 0;
        try {
            connection = MySQLConnector.getConnection();
            langSet = getAllLangNames(connection);
            if (langSet == null) {
                throw new SQLException("error occurred while trying to read all lang", "45000");
            }
            category.setId(id);
            statement = connection.prepareStatement(SQL.Category.READ_STATUS_BY_ID);
            statement.setInt(++i, id);
            statement.execute();
            try (ResultSet resultSet = statement.getResultSet()) {
                if (resultSet.next()) {
                    i = 0;
                    category.setStatus(Category.Status.valueOf(resultSet.getString(++i)));
                }
            } catch (SQLException e) {
                e.printStackTrace();
                throw e;
            }
            category.setLangName(getLangNameMap(connection, langSet, id));
            return category;
        } catch (SQLException e) {
            e.printStackTrace();
            throw new DBException("State: " + e.getSQLState() + " Message: " + e.getMessage());
        } finally {
            close(statement);
            close(connection);
        }
    }

    @Override
    public void update(Category entity) {
        Connection connection = null;
        PreparedStatement statement = null;
        int i = 0;
        try {
            connection = MySQLConnector.getConnection();
            connection.setAutoCommit(false);
            connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
            statement = connection.prepareStatement(SQL.Category.UPDATE_STATUS);
            statement.setString(++i, entity.getStatus().name());
            statement.setInt(++i, entity.getId());
            statement.execute();
            HashSet<Map.Entry<Integer, String>> set = mapEntrySetLangNameToIds(connection, entity.getLangName().entrySet());
            statement = connection.prepareStatement(SQL.Category.UPDATE_NAME);
            for (Map.Entry<Integer, String > e:
                 set) {
                i = 0;
                statement.setString(++i, e.getValue());
                statement.setInt(++i, entity.getId());
                statement.setInt(++i, e.getKey());
                statement.execute();
            }
            connection.commit();
        } catch (SQLException e) {
            rollbackTransaction(connection);
            processSQLExceptionOnDBChange(e);
        } finally {
            close(statement);
            close(connection);
        }
    }

    private Set<String> getAllLangNames(Connection connection) throws SQLException {
        PreparedStatement statement = connection.prepareStatement(SQL.Category.READ_ALL_LANG_NAMES);
        statement.execute();
        HashSet<String> langSet = null;
        int i = 0;
        try (ResultSet langRS = statement.getResultSet()) {
            if (langRS.next()) {
                langSet = new HashSet<>();
                langSet.add(langRS.getString(++i));
                while (langRS.next()) {
                    i = 0;
                    langSet.add(langRS.getString(++i));
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
            throw e;
        }
        return langSet;
    }

    private HashMap<String, String> getLangNameMap(Connection connection, Set<String> langSet, int categoryId) throws SQLException {
        HashMap<String, String> map = new HashMap<>();
        int i;
        for (String lang :
                langSet) {
            i = 0;
            PreparedStatement statement = connection.prepareStatement(SQL.Category.READ_CATEGORY_NAME_WITH_LOCALE);
            statement.setInt(++i, categoryId);
            statement.setString(++i, lang);
            statement.execute();
            i = 0;
            try (ResultSet nameRS = statement.getResultSet()) {
                nameRS.next();
                map.put(lang, nameRS.getString(++i));
            } catch (SQLException e) {
                e.printStackTrace();
                throw e;
            }
        }
        return map;
    }

    private HashSet<Map.Entry<Integer, String>> mapEntrySetLangNameToIds(Connection connection, Set<Map.Entry<String, String>> nameSet) throws SQLException {
        int i;
        PreparedStatement statement = connection.prepareStatement(SQL.Category.READ_ID_FOR_LANG_NAME);
        HashSet<Map.Entry<Integer, String>> res = new HashSet<>();
        for (Map.Entry<String, String> entry:
             nameSet) {
            i = 0;
            statement.setString(++i, entry.getKey());
            statement.execute();
            try(ResultSet resultSet = statement.getResultSet()){
                int id = 0;
                i = 0;
                if(resultSet.next()){
                    id = resultSet.getInt(++i);
                }
                if(id == 0){
                    throw new SQLException("could not find langId for lang=" + entry.getKey(), "45000");
                }
                res.add(new AbstractMap.SimpleEntry<>(id, entry.getValue()));
            } catch (SQLException e){
                e.printStackTrace();
                throw e;
            }
        }
        return res;
    }

}
